

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Symbolic Abstraction &mdash; Arlib Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a74d790d"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Symbolic Finite Automata" href="symautomata.html" />
    <link rel="prev" title="SMT Solving" href="smt.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Arlib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="topics.html">Research Topics and Thesis Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="abduction.html">Abduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="allsmt.html">AllSMT</a></li>
<li class="toctree-l1"><a class="reference internal" href="backbone.html">Backbone Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="chctools.html">Constrained Horn Clauses (CHC) Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="counting.html">Model Counting</a></li>
<li class="toctree-l1"><a class="reference internal" href="ff.html">SMT Solving for Finite Field</a></li>
<li class="toctree-l1"><a class="reference internal" href="ff.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="itp.html">Interactive Theorem Proving (ITP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="monabs.html">Monadic Predicate Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html">Optimization Modulo Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="pcdclt.html">Parallel SMT CDCL(T) Solving</a></li>
<li class="toctree-l1"><a class="reference internal" href="polyhorn.html">PolyHorn: Polynomial Horn Clause Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="prob.html">Probabilistic Reasoning (arlib/prob)</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers.html">Playing wth Quantifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Model Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="smt.html">SMT Solving</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Symbolic Abstraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#core-concepts">Core Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#abstract-domain">Abstract Domain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concretization-and-abstraction">Concretization and Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#precision-metrics">Precision Metrics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#abstract-interpretation-ai-symabs">Abstract Interpretation (ai_symabs)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#supported-abstract-domains">Supported Abstract Domains</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interval-domain"><strong>Interval Domain</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#sign-domain"><strong>Sign Domain</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#reduced-product-domain"><strong>Reduced Product Domain</strong></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#abstraction-algorithms">Abstraction Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bilateral-algorithm"><strong>Bilateral Algorithm</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rsy-algorithm"><strong>RSY Algorithm</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#omt-based-symbolic-abstraction-omt-symabs">OMT-based Symbolic Abstraction (omt_symabs)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-features">Key Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-arithmetic-abstraction">Linear Arithmetic Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bit-vector-abstraction">Bit-Vector Abstraction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#predicate-abstraction-predicate-abstraction">Predicate Abstraction (predicate_abstraction)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#core-algorithm">Core Algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additional-components">Additional Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-counting-based-abstract-interpretation-mcai">Model Counting-based Abstract Interpretation (mcai)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#congruence-closure-based-abstraction-congruence">Congruence Closure-based Abstraction (congruence)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#range-set-sat-based-abstraction-rangeset-sat">Range Set SAT-based Abstraction (rangeset_sat)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage-examples">Usage Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-symbolic-abstraction">Basic Symbolic Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#omt-based-abstraction">OMT-based Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predicate-abstraction-example">Predicate Abstraction Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#applications">Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#program-verification">Program Verification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#security-analysis">Security Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hardware-verification">Hardware Verification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimization-and-synthesis">Optimization and Synthesis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#performance-considerations">Performance Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#choosing-the-right-approach">Choosing the Right Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalability-trade-offs">Scalability Trade-offs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#future-directions">Future Directions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#research-areas">Research Areas</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#core-theory">Core Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstract-interpretation">Abstract Interpretation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">OMT-based Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predicate-abstraction">Predicate Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applications-and-case-studies">Applications and Case Studies</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="symautomata.html">Symbolic Finite Automata</a></li>
<li class="toctree-l1"><a class="reference internal" href="unsat_core.html">UNSAT Core Extraction</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Arlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Symbolic Abstraction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/symbolic_abstraction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="symbolic-abstraction">
<h1>Symbolic Abstraction<a class="headerlink" href="#symbolic-abstraction" title="Link to this heading"></a></h1>
<p>Symbolic abstraction is a technique that computes the best abstract domain element
that overapproximates a given formula in first-order logic. It serves as a bridge between
concrete program analysis and efficient abstract reasoning, enabling scalable verification
and analysis of complex systems.</p>
<p>The key idea is to transform a concrete logical formula into an abstract representation
that captures the essential behavior while being more amenable to automated analysis.
This abstraction preserves important properties (like satisfiability) while discarding
unnecessary details that would make analysis computationally expensive.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Arlib’s symbolic abstraction module (<code class="docutils literal notranslate"><span class="pre">arlib/symabs</span></code>) provides a comprehensive suite
of abstraction techniques for program analysis and verification. The module is organized
around several key approaches:</p>
<ol class="arabic simple">
<li><p><strong>Abstract Interpretation-based Symbolic Abstraction</strong> (<code class="docutils literal notranslate"><span class="pre">ai_symabs</span></code>)</p></li>
<li><p><strong>Optimization Modulo Theory-based Symbolic Abstraction</strong> (<code class="docutils literal notranslate"><span class="pre">omt_symabs</span></code>)</p></li>
<li><p><strong>Predicate Abstraction</strong> (<code class="docutils literal notranslate"><span class="pre">predicate_abstraction</span></code>)</p></li>
<li><p><strong>Model Counting-based Abstract Interpretation</strong> (<code class="docutils literal notranslate"><span class="pre">mcai</span></code>)</p></li>
<li><p><strong>Congruence Closure-based Abstraction</strong> (<code class="docutils literal notranslate"><span class="pre">congruence</span></code>)</p></li>
<li><p><strong>Range Set SAT-based Abstraction</strong> (<code class="docutils literal notranslate"><span class="pre">rangeset_sat</span></code>)</p></li>
</ol>
<p>Each approach offers different trade-offs between precision, scalability, and applicability
to different problem domains.</p>
</section>
<section id="core-concepts">
<h2>Core Concepts<a class="headerlink" href="#core-concepts" title="Link to this heading"></a></h2>
<section id="abstract-domain">
<h3>Abstract Domain<a class="headerlink" href="#abstract-domain" title="Link to this heading"></a></h3>
<p>An abstract domain defines the lattice structure and operations for abstract elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AbstractDomain</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>  <span class="c1"># Least upper bound</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>  <span class="c1"># Greatest lower bound</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gamma_hat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>  <span class="c1"># Concretization function</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">):</span>   <span class="c1"># Find concrete model</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">gamma_hat</span></code> function translates an abstract element back to a concrete formula,
while the <code class="docutils literal notranslate"><span class="pre">join</span></code> operation computes the least upper bound in the abstract lattice.</p>
</section>
<section id="concretization-and-abstraction">
<h3>Concretization and Abstraction<a class="headerlink" href="#concretization-and-abstraction" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Concretization</strong> (γ̂): Maps abstract elements to concrete formulas</p></li>
<li><p><strong>Abstraction</strong>: Maps concrete formulas to abstract elements</p></li>
<li><p><strong>Galois Connection</strong>: The pair (α, γ̂) forms a Galois connection if α(γ̂(α̂)) = α̂</p></li>
</ul>
</section>
<section id="precision-metrics">
<h3>Precision Metrics<a class="headerlink" href="#precision-metrics" title="Link to this heading"></a></h3>
<p>The quality of an abstraction is measured by:</p>
<ul class="simple">
<li><p><strong>Precision</strong>: How closely the abstract formula approximates the concrete one</p></li>
<li><p><strong>Scalability</strong>: Computational cost of abstraction computation</p></li>
<li><p><strong>Expressiveness</strong>: Ability to capture important program properties</p></li>
</ul>
</section>
</section>
<section id="abstract-interpretation-ai-symabs">
<h2>Abstract Interpretation (ai_symabs)<a class="headerlink" href="#abstract-interpretation-ai-symabs" title="Link to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ai_symabs</span></code> submodule implements classic abstract interpretation domains based on
Thakur’s PhD thesis. It provides a framework for computing symbolic abstractions using
various abstract domains.</p>
<section id="supported-abstract-domains">
<h3>Supported Abstract Domains<a class="headerlink" href="#supported-abstract-domains" title="Link to this heading"></a></h3>
<section id="interval-domain">
<h4><strong>Interval Domain</strong><a class="headerlink" href="#interval-domain" title="Link to this heading"></a></h4>
<p>The interval domain represents variable ranges using lower and upper bounds:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.interval.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntervalDomain</span>

<span class="c1"># Create interval domain for variables [&#39;x&#39;, &#39;y&#39;]</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">IntervalDomain</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="c1"># Abstract state represents: x ∈ [0, 10], y ∈ [-5, 5]</span>
<span class="c1"># This concretizes to: 0 ≤ x ∧ x ≤ 10 ∧ -5 ≤ y ∧ y ≤ 5</span>
</pre></div>
</div>
</section>
<section id="sign-domain">
<h4><strong>Sign Domain</strong><a class="headerlink" href="#sign-domain" title="Link to this heading"></a></h4>
<p>The sign domain tracks the sign of variables (negative, zero, positive):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.sign.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">SignDomain</span>

<span class="c1"># Sign domain for variable &#39;x&#39;</span>
<span class="c1"># Possible abstract values: -, 0, +, T (top)</span>
</pre></div>
</div>
</section>
<section id="reduced-product-domain">
<h4><strong>Reduced Product Domain</strong><a class="headerlink" href="#reduced-product-domain" title="Link to this heading"></a></h4>
<p>Combines multiple domains for better precision:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.reduced_product.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReducedProductDomain</span>

<span class="c1"># Combine interval and sign domains</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">ReducedProductDomain</span><span class="p">([</span><span class="n">interval_domain</span><span class="p">,</span> <span class="n">sign_domain</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="abstraction-algorithms">
<h3>Abstraction Algorithms<a class="headerlink" href="#abstraction-algorithms" title="Link to this heading"></a></h3>
<section id="bilateral-algorithm">
<h4><strong>Bilateral Algorithm</strong><a class="headerlink" href="#bilateral-algorithm" title="Link to this heading"></a></h4>
<p>The bilateral algorithm efficiently computes abstractions by working with both the
positive and negative forms of the formula:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.algorithms.bilateral</span><span class="w"> </span><span class="kn">import</span> <span class="n">bilateral</span>

<span class="c1"># Compute abstraction using bilateral algorithm</span>
<span class="n">abstract_state</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">concrete_formula</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="rsy-algorithm">
<h4><strong>RSY Algorithm</strong><a class="headerlink" href="#rsy-algorithm" title="Link to this heading"></a></h4>
<p>Recursive abstraction refinement algorithm that iteratively improves precision:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.algorithms.rsy</span><span class="w"> </span><span class="kn">import</span> <span class="n">rsy</span>

<span class="c1"># Compute abstraction with RSY algorithm</span>
<span class="n">abstract_state</span> <span class="o">=</span> <span class="n">rsy</span><span class="p">(</span><span class="n">concrete_formula</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="omt-based-symbolic-abstraction-omt-symabs">
<h2>OMT-based Symbolic Abstraction (omt_symabs)<a class="headerlink" href="#omt-based-symbolic-abstraction-omt-symabs" title="Link to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">omt_symabs</span></code> submodule uses Optimization Modulo Theory (OMT) solvers to compute
optimal abstractions. This approach leverages modern OMT engines like Z3’s optimizer
to find the best abstract representation.</p>
<section id="key-features">
<h3>Key Features<a class="headerlink" href="#key-features" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Optimal Abstractions</strong>: Computes the most precise abstraction within the domain</p></li>
<li><p><strong>Multiple Domains</strong>: Supports intervals, zones, and octagons</p></li>
<li><p><strong>Theory Support</strong>: Handles both linear arithmetic (LIA/LRA) and bit-vectors</p></li>
</ul>
</section>
<section id="linear-arithmetic-abstraction">
<h3>Linear Arithmetic Abstraction<a class="headerlink" href="#linear-arithmetic-abstraction" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.omt_symabs.lira_symbolic_abstraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">LIRASymbolicAbstraction</span>

<span class="c1"># Create LIRA symbolic abstraction</span>
<span class="n">symabs</span> <span class="o">=</span> <span class="n">LIRASymbolicAbstraction</span><span class="p">()</span>

<span class="c1"># Initialize from SMT formula</span>
<span class="n">symabs</span><span class="o">.</span><span class="n">init_from_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>

<span class="c1"># Compute interval abstraction</span>
<span class="n">interval_abs</span> <span class="o">=</span> <span class="n">symabs</span><span class="o">.</span><span class="n">compute_interval_abstraction</span><span class="p">()</span>

<span class="c1"># Compute zone abstraction</span>
<span class="n">zone_abs</span> <span class="o">=</span> <span class="n">symabs</span><span class="o">.</span><span class="n">compute_zone_abstraction</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="bit-vector-abstraction">
<h3>Bit-Vector Abstraction<a class="headerlink" href="#bit-vector-abstraction" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.omt_symabs.bv_symbolic_abstraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">BVSymbolicAbstraction</span>

<span class="c1"># Create bit-vector symbolic abstraction</span>
<span class="n">bv_symabs</span> <span class="o">=</span> <span class="n">BVSymbolicAbstraction</span><span class="p">()</span>

<span class="c1"># Initialize with bit-vector formula</span>
<span class="n">bv_symabs</span><span class="o">.</span><span class="n">init_from_formula</span><span class="p">(</span><span class="n">bv_formula</span><span class="p">)</span>

<span class="c1"># Compute abstraction</span>
<span class="n">abstract_state</span> <span class="o">=</span> <span class="n">bv_symabs</span><span class="o">.</span><span class="n">compute_abstraction</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="predicate-abstraction-predicate-abstraction">
<h2>Predicate Abstraction (predicate_abstraction)<a class="headerlink" href="#predicate-abstraction-predicate-abstraction" title="Link to this heading"></a></h2>
<p>Predicate abstraction computes the strongest Boolean combination of given predicates
that is entailed by the concrete formula. This approach is particularly effective for
software verification tasks.</p>
<section id="core-algorithm">
<h3>Core Algorithm<a class="headerlink" href="#core-algorithm" title="Link to this heading"></a></h3>
<p>The predicate abstraction algorithm works by:</p>
<ol class="arabic simple">
<li><p>Finding satisfying models of the concrete formula</p></li>
<li><p>Evaluating predicates in each model</p></li>
<li><p>Constructing the strongest Boolean formula consistent with the evaluations</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.predicate_abstraction.predicate_abstraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_predicate_abstraction</span>

<span class="c1"># Define predicates</span>
<span class="n">predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1"># Concrete formula: x &gt; 5 ∧ y &gt; 3 ∧ x + y &lt; 8</span>
<span class="n">concrete_formula</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>

<span class="c1"># Compute predicate abstraction</span>
<span class="n">abstract_formula</span> <span class="o">=</span> <span class="n">compute_predicate_abstraction</span><span class="p">(</span><span class="n">concrete_formula</span><span class="p">,</span> <span class="n">predicates</span><span class="p">)</span>
<span class="c1"># Result: x &gt; 0 ∧ y &gt; 0 ∧ x + y &lt; 10 (strongest consequence)</span>
</pre></div>
</div>
</section>
</section>
<section id="additional-components">
<h2>Additional Components<a class="headerlink" href="#additional-components" title="Link to this heading"></a></h2>
<section id="model-counting-based-abstract-interpretation-mcai">
<h3>Model Counting-based Abstract Interpretation (mcai)<a class="headerlink" href="#model-counting-based-abstract-interpretation-mcai" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mcai</span></code> submodule combines model counting with abstract interpretation to provide
precision metrics and analysis for different abstract domains. This is particularly
useful for:</p>
<ul class="simple">
<li><p>Evaluating abstraction quality</p></li>
<li><p>Comparing different abstract domains</p></li>
<li><p>Bit-vector formula analysis</p></li>
</ul>
</section>
<section id="congruence-closure-based-abstraction-congruence">
<h3>Congruence Closure-based Abstraction (congruence)<a class="headerlink" href="#congruence-closure-based-abstraction-congruence" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">congruence</span></code> submodule implements congruence closure techniques for abstraction,
particularly useful for equality reasoning and uninterpreted functions.</p>
</section>
<section id="range-set-sat-based-abstraction-rangeset-sat">
<h3>Range Set SAT-based Abstraction (rangeset_sat)<a class="headerlink" href="#range-set-sat-based-abstraction-rangeset-sat" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rangeset_sat</span></code> submodule provides SAT-based abstraction techniques for range
and set operations over bit-vectors, offering efficient analysis for hardware verification.</p>
</section>
</section>
<section id="usage-examples">
<h2>Usage Examples<a class="headerlink" href="#usage-examples" title="Link to this heading"></a></h2>
<section id="basic-symbolic-abstraction">
<h3>Basic Symbolic Abstraction<a class="headerlink" href="#basic-symbolic-abstraction" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">z3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.interval.domain</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntervalDomain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.ai_symabs.domains.algorithms.bilateral</span><span class="w"> </span><span class="kn">import</span> <span class="n">bilateral</span>

<span class="c1"># Define concrete formula: 0 ≤ x ∧ x ≤ 10 ∧ x + y = 15</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="n">formula</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>

<span class="c1"># Create interval domain</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">IntervalDomain</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

<span class="c1"># Compute abstraction</span>
<span class="n">abstract_state</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>

<span class="c1"># Get concrete representation</span>
<span class="n">concrete_repr</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">gamma_hat</span><span class="p">(</span><span class="n">abstract_state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Abstract state concretizes to: </span><span class="si">{</span><span class="n">concrete_repr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="omt-based-abstraction">
<h3>OMT-based Abstraction<a class="headerlink" href="#omt-based-abstraction" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.omt_symabs.lira_symbolic_abstraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">LIRASymbolicAbstraction</span>

<span class="c1"># Create symbolic abstraction engine</span>
<span class="n">symabs</span> <span class="o">=</span> <span class="n">LIRASymbolicAbstraction</span><span class="p">()</span>

<span class="c1"># Load formula from file</span>
<span class="n">symabs</span><span class="o">.</span><span class="n">init_from_file</span><span class="p">(</span><span class="s1">&#39;example.smt2&#39;</span><span class="p">)</span>

<span class="c1"># Set OMT engine type</span>
<span class="n">symabs</span><span class="o">.</span><span class="n">set_omt_engine_type</span><span class="p">(</span><span class="s1">&#39;z3opt&#39;</span><span class="p">)</span>

<span class="c1"># Compute optimal interval abstraction</span>
<span class="n">interval_abs</span> <span class="o">=</span> <span class="n">symabs</span><span class="o">.</span><span class="n">compute_interval_abstraction</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interval abstraction: </span><span class="si">{</span><span class="n">interval_abs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="predicate-abstraction-example">
<h3>Predicate Abstraction Example<a class="headerlink" href="#predicate-abstraction-example" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">z3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">arlib.symabs.predicate_abstraction.predicate_abstraction</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_predicate_abstraction</span>

<span class="c1"># Define variables and predicates</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="n">predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1"># Concrete formula representing a program path</span>
<span class="n">concrete</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span>

<span class="c1"># Compute abstraction</span>
<span class="n">abstract</span> <span class="o">=</span> <span class="n">compute_predicate_abstraction</span><span class="p">(</span><span class="n">concrete</span><span class="p">,</span> <span class="n">predicates</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Predicate abstraction: </span><span class="si">{</span><span class="n">abstract</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Link to this heading"></a></h2>
<p>Symbolic abstraction techniques find applications in various domains:</p>
<section id="program-verification">
<h3>Program Verification<a class="headerlink" href="#program-verification" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Software Model Checking</strong>: Abstract program states to enable scalable verification</p></li>
<li><p><strong>Shape Analysis</strong>: Abstract heap structures and pointer relationships</p></li>
<li><p><strong>Numerical Program Analysis</strong>: Abstract numerical computations for overflow/underflow detection</p></li>
</ul>
</section>
<section id="security-analysis">
<h3>Security Analysis<a class="headerlink" href="#security-analysis" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Information Flow Analysis</strong>: Abstract security levels and taint propagation</p></li>
<li><p><strong>Cryptographic Protocol Verification</strong>: Abstract cryptographic operations</p></li>
<li><p><strong>Buffer Overflow Detection</strong>: Abstract memory operations and bounds checking</p></li>
</ul>
</section>
<section id="hardware-verification">
<h3>Hardware Verification<a class="headerlink" href="#hardware-verification" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Bit-Vector Abstraction</strong>: Abstract bit-level operations for hardware verification</p></li>
<li><p><strong>Range Analysis</strong>: Abstract value ranges for timing and power analysis</p></li>
<li><p><strong>Equivalence Checking</strong>: Abstract circuit behaviors for equivalence verification</p></li>
</ul>
</section>
<section id="optimization-and-synthesis">
<h3>Optimization and Synthesis<a class="headerlink" href="#optimization-and-synthesis" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Compiler Optimizations</strong>: Abstract program semantics for optimization</p></li>
<li><p><strong>Program Synthesis</strong>: Abstract specifications for synthesis tasks</p></li>
<li><p><strong>Test Generation</strong>: Abstract program paths for test case generation</p></li>
</ul>
</section>
</section>
<section id="performance-considerations">
<h2>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Link to this heading"></a></h2>
<section id="choosing-the-right-approach">
<h3>Choosing the Right Approach<a class="headerlink" href="#choosing-the-right-approach" title="Link to this heading"></a></h3>
<p><strong>When to use ai_symabs:</strong></p>
<ul class="simple">
<li><p>Fast analysis with reasonable precision</p></li>
<li><p>Classic abstract domains (intervals, signs, octagons)</p></li>
<li><p>Large-scale program analysis</p></li>
<li><p>Resource-constrained environments</p></li>
</ul>
<p><strong>When to use omt_symabs:</strong></p>
<ul class="simple">
<li><p>Need for optimal precision</p></li>
<li><p>Linear arithmetic formulas</p></li>
<li><p>Small to medium-sized problems</p></li>
<li><p>When exact bounds are critical</p></li>
</ul>
<p><strong>When to use predicate_abstraction:</strong></p>
<ul class="simple">
<li><p>Software verification tasks</p></li>
<li><p>User-defined predicates available</p></li>
<li><p>Boolean program analysis</p></li>
<li><p>Counterexample-guided abstraction refinement (CEGAR)</p></li>
</ul>
</section>
<section id="scalability-trade-offs">
<h3>Scalability Trade-offs<a class="headerlink" href="#scalability-trade-offs" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Precision vs. Scalability</strong>: OMT provides highest precision but scales poorly</p></li>
<li><p><strong>Domain Selection</strong>: Interval domains offer good precision/scalability balance</p></li>
<li><p><strong>Algorithm Choice</strong>: Bilateral algorithm often provides best performance</p></li>
<li><p><strong>Parallelization</strong>: Many abstraction algorithms can be parallelized</p></li>
</ul>
</section>
</section>
<section id="future-directions">
<h2>Future Directions<a class="headerlink" href="#future-directions" title="Link to this heading"></a></h2>
<section id="research-areas">
<h3>Research Areas<a class="headerlink" href="#research-areas" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>Theory Development</strong>:
- New abstract domains for emerging computing paradigms
- Combination methods for heterogeneous domains
- Completeness and decidability results for abstraction algorithms</p></li>
<li><p><strong>Algorithm Improvement</strong>:
- Machine learning-guided abstraction refinement
- Parallel and distributed abstraction algorithms
- Incremental abstraction techniques for dynamic analysis</p></li>
<li><p><strong>Integration with Modern Verification</strong>:
- Deep learning integration for abstraction learning
- Quantum computing abstraction techniques
- Blockchain and smart contract verification</p></li>
<li><p><strong>Industrial Applications</strong>:
- Large-scale software verification
- Autonomous systems analysis
- Cyber-physical systems verification</p></li>
</ol>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<section id="core-theory">
<h3>Core Theory<a class="headerlink" href="#core-theory" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Thakur, A. V.</strong> (2014). <em>Symbolic Abstraction: Algorithms and Applications</em>. Ph.D. dissertation, University of Wisconsin-Madison. <a class="reference external" href="https://www.cs.wisc.edu/~aws/pubs/thesis.pdf">https://www.cs.wisc.edu/~aws/pubs/thesis.pdf</a></p></li>
<li><p><strong>Cousot, P., &amp; Cousot, R.</strong> (1977). <em>Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</em>. POPL’77.</p></li>
<li><p><strong>Graf, S., &amp; Saïdi, H.</strong> (1997). <em>Construction of abstract state graphs with PVS</em>. CAV’97.</p></li>
</ul>
</section>
<section id="abstract-interpretation">
<h3>Abstract Interpretation<a class="headerlink" href="#abstract-interpretation" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Cousot, P., Cousot, R., &amp; Logozzo, F.</strong> (2013). <em>A parametric segmentation functor for fully automatic and scalable array content analysis</em>. POPL’13.</p></li>
<li><p><strong>Miné, A.</strong> (2006). <em>The octagon abstract domain</em>. Higher-Order and Symbolic Computation.</p></li>
<li><p><strong>Singh, G., Püschel, M., &amp; Vechev, M.</strong> (2015). <em>Fast numerical program analysis with reinforcement learning</em>. CAV’15.</p></li>
</ul>
</section>
<section id="id1">
<h3>OMT-based Abstraction<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Sebastiani, R., &amp; Trentin, P.</strong> (2015). <em>OPTIMathSAT: a tool for optimization modulo theories</em>. CAV’15.</p></li>
<li><p><strong>Borralleras, C., Larraz, D., Oliveras, A., Rodríguez-Carbonell, E., &amp; Rubio, A.</strong> (2019). <em>The iSAT solver</em>. TACAS’19.</p></li>
</ul>
</section>
<section id="predicate-abstraction">
<h3>Predicate Abstraction<a class="headerlink" href="#predicate-abstraction" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Graf, S., &amp; Saïdi, H.</strong> (1997). <em>Construction of abstract state graphs with PVS</em>. CAV’97.</p></li>
<li><p><strong>Ball, T., Majumdar, R., Millstein, T., &amp; Rajamani, S. K.</strong> (2001). <em>Automatic predicate abstraction of C programs</em>. PLDI’01.</p></li>
<li><p><strong>Henzinger, T. A., Jhala, R., Majumdar, R., &amp; McMillan, K. L.</strong> (2004). <em>Abstractions from proofs</em>. POPL’04.</p></li>
</ul>
</section>
<section id="applications-and-case-studies">
<h3>Applications and Case Studies<a class="headerlink" href="#applications-and-case-studies" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><strong>Chen, Y., Wang, Y., Zhu, Z., Song, L., &amp; Zhang, L.</strong> (2021). <em>Program Analysis via Efficient Symbolic Abstraction</em>. OOPSLA’21.</p></li>
<li><p><strong>Albarghouthi, A., Li, Y., &amp; Zhang, L.</strong> (2019). <em>Automating Abstract Interpretation</em>. VMCAI’16.</p></li>
<li><p><strong>Gulwani, S., &amp; Tiwari, A.</strong> (2007). <em>Combining abstract interpretation with model checking</em>. ESEC/FSE’07.</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="smt.html" class="btn btn-neutral float-left" title="SMT Solving" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="symautomata.html" class="btn btn-neutral float-right" title="Symbolic Finite Automata" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024-2025, ZJU Automated Reasoning Group.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>