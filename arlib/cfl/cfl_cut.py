"""
Graph Cut for CFL Reachability
(generated by LLM; to be checked)

A graph cut is a partition of a graph into two disjoint subsets of vertices.
This module provides functionality for computing graph cuts in the context
of CFL-reachability analysis, including minimum cuts and graph partitioning.
"""

from typing import List, Dict, Any, Union, Tuple, Optional, Set
from collections import defaultdict, deque
import sys


class GraphCut:
    """
    A class for computing graph cuts in CFL-reachability analysis.

    This class provides methods for finding minimum cuts and partitioning
    graphs into two disjoint subsets. It's designed to work with the
    graph representations used in CFL-reachability analysis.

    Attributes:
        source_set (Set[Any]): Set of vertices in the source partition.
        sink_set (Set[Any]): Set of vertices in the sink partition.
        cut_edges (List[Tuple[Any, Any, str]]): List of edges that cross the cut.
        cut_value (int): The value/weight of the cut.

    Example:
        >>> graph_cut = GraphCut()
        >>> cut_value = graph_cut.find_min_cut(graph, source, sink)
        >>> partition = graph_cut.partition_graph(graph, threshold)
    """

    def __init__(self) -> None:
        """Initialize an empty graph cut."""
        self.source_set: Set[Any] = set()
        self.sink_set: Set[Any] = set()
        self.cut_edges: List[Tuple[Any, Any, str]] = []
        self.cut_value: int = 0

    def find_min_cut(self, graph: Any, source: Any, sink: Any) -> int:
        """
        Find the minimum cut between source and sink vertices using Ford-Fulkerson algorithm.

        This method implements the Ford-Fulkerson algorithm with BFS to find the
        maximum flow, which corresponds to the minimum cut value.

        Args:
            graph: The input graph (Graph object from graph.py).
            source: The source vertex.
            sink: The sink vertex.

        Returns:
            int: The value of the minimum cut.

        Raises:
            ValueError: If source or sink vertices don't exist in the graph.
        """
        vertices = graph.get_vertice()
        if source not in vertices or sink not in vertices:
            raise ValueError("Source or sink vertex not found in graph")

        # Build adjacency list for flow network
        adj = defaultdict(list)
        edges = graph.output_edge()

        # Create flow network
        for edge in edges:
            label, u, v = edge[0], edge[1], edge[2]
            adj[u].append((v, 1))  # Assume unit capacity
            adj[v].append((u, 0))  # Reverse edge with zero capacity

        # Ford-Fulkerson algorithm
        max_flow = 0
        parent = {}

        while True:
            # BFS to find augmenting path
            visited = set()
            queue = deque([source])
            visited.add(source)
            parent.clear()

            found_path = False
            while queue and not found_path:
                u = queue.popleft()
                for v, capacity in adj[u]:
                    if v not in visited and capacity > 0:
                        visited.add(v)
                        parent[v] = u
                        if v == sink:
                            found_path = True
                            break
                        queue.append(v)

            if not found_path:
                break

            # Find bottleneck capacity
            path_flow = sys.maxsize
            s = sink
            while s != source:
                path_flow = min(path_flow, self._get_edge_capacity(adj, parent[s], s))
                s = parent[s]

            # Update residual capacities
            s = sink
            while s != source:
                u = parent[s]
                self._update_edge_capacity(adj, u, s, -path_flow)
                self._update_edge_capacity(adj, s, u, path_flow)
                s = parent[s]

            max_flow += path_flow

        self.cut_value = max_flow
        self._compute_cut_sets(graph, source, visited)
        return max_flow

    def _get_edge_capacity(self, adj: Dict[Any, List[Tuple[Any, int]]], u: Any, v: Any) -> int:
        """Get the capacity of an edge in the adjacency list."""
        for neighbor, capacity in adj[u]:
            if neighbor == v:
                return capacity
        return 0

    def _update_edge_capacity(self, adj: Dict[Any, List[Tuple[Any, int]]], u: Any, v: Any, delta: int) -> None:
        """Update the capacity of an edge in the adjacency list."""
        for i, (neighbor, capacity) in enumerate(adj[u]):
            if neighbor == v:
                adj[u][i] = (neighbor, capacity + delta)
                return

    def _compute_cut_sets(self, graph: Any, source: Any, reachable: Set[Any]) -> None:
        """Compute the source and sink sets based on reachability from source."""
        vertices = set(graph.get_vertice())
        self.source_set = reachable.copy()
        self.sink_set = vertices - reachable
        self.cut_edges = self._find_cut_edges(graph)

    def _find_cut_edges(self, graph: Any) -> List[Tuple[Any, Any, str]]:
        """Find edges that cross the cut."""
        cut_edges = []
        edges = graph.output_edge()

        for edge in edges:
            label, u, v = edge[0], edge[1], edge[2]
            if (u in self.source_set and v in self.sink_set) or \
               (v in self.source_set and u in self.sink_set):
                cut_edges.append((u, v, label))

        return cut_edges

    def partition_graph(self, graph: Any, threshold: int = 0) -> Tuple[Set[Any], Set[Any]]:
        """
        Partition the graph into two sets based on connectivity analysis.

        This method attempts to find a natural partition of the graph by
        analyzing connectivity and edge patterns.

        Args:
            graph: The input graph (Graph object from graph.py).
            threshold: Minimum size for a partition (default: 0).

        Returns:
            Tuple[Set[Any], Set[Any]]: A tuple containing the two partitions.
        """
        vertices = set(graph.get_vertice())
        if len(vertices) < 2:
            return vertices, set()

        # Simple partitioning based on connectivity
        visited = set()
        components = []

        for vertex in vertices:
            if vertex not in visited:
                component = self._bfs_component(graph, vertex, visited)
                if len(component) >= threshold:
                    components.append(component)

        if len(components) < 2:
            # If graph is strongly connected, try to find a balanced cut
            return self._balanced_partition(graph, vertices)

        # Use the two largest components
        components.sort(key=len, reverse=True)
        self.source_set = components[0]
        self.sink_set = components[1] if len(components) > 1 else set()

        return self.source_set, self.sink_set

    def _bfs_component(self, graph: Any, start: Any, visited: Set[Any]) -> Set[Any]:
        """Find a connected component using BFS."""
        component = set()
        queue = deque([start])

        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                component.add(vertex)

                # Add neighbors
                edges = graph.output_edge()
                for edge in edges:
                    label, u, v = edge[0], edge[1], edge[2]
                    if u == vertex and v not in visited:
                        queue.append(v)
                    elif v == vertex and u not in visited:
                        queue.append(u)

        return component

    def _balanced_partition(self, graph: Any, vertices: Set[Any]) -> Tuple[Set[Any], Set[Any]]:
        """Create a balanced partition by splitting vertices roughly in half."""
        vertex_list = list(vertices)
        mid = len(vertex_list) // 2
        self.source_set = set(vertex_list[:mid])
        self.sink_set = set(vertex_list[mid:])
        return self.source_set, self.sink_set

    def get_cut_edges(self) -> List[Tuple[Any, Any, str]]:
        """Get the edges that cross the cut."""
        return self.cut_edges.copy()

    def get_source_set(self) -> Set[Any]:
        """Get the source partition."""
        return self.source_set.copy()

    def get_sink_set(self) -> Set[Any]:
        """Get the sink partition."""
        return self.sink_set.copy()

    def get_cut_value(self) -> int:
        """Get the value of the cut."""
        return self.cut_value

    def is_valid_cut(self, graph: Any) -> bool:
        """
        Check if the current cut is valid (partitions all vertices).

        Args:
            graph: The input graph (Graph object from graph.py).

        Returns:
            bool: True if the cut is valid, False otherwise.
        """
        vertices = set(graph.get_vertice())
        union = self.source_set.union(self.sink_set)
        intersection = self.source_set.intersection(self.sink_set)
        return union == vertices and len(intersection) == 0

    def __str__(self) -> str:
        """String representation of the graph cut."""
        return f"GraphCut(source_size={len(self.source_set)}, sink_size={len(self.sink_set)}, cut_value={self.cut_value})"

    def __repr__(self) -> str:
        """Detailed string representation of the graph cut."""
        return (f"GraphCut(source_set={self.source_set}, sink_set={self.sink_set}, "
                f"cut_edges={self.cut_edges}, cut_value={self.cut_value})")
