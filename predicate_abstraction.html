

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Predicate Abstraction &mdash; Arlib Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a74d790d"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Arlib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="topics.html">Research Topics and Thesis Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="abduction.html">Abduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="allsmt.html">AllSMT</a></li>
<li class="toctree-l1"><a class="reference internal" href="backbone.html">Backbone Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="chctools.html">Constrained Horn Clauses (CHC) Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="counting.html">Model Counting</a></li>
<li class="toctree-l1"><a class="reference internal" href="ff.html">SMT Solving for Finite Field</a></li>
<li class="toctree-l1"><a class="reference internal" href="ff.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="itp.html">Interactive Theorem Proving (ITP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="monabs.html">Monadic Predicate Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html">Optimization Modulo Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="pcdclt.html">Parallel SMT CDCL(T) Solving</a></li>
<li class="toctree-l1"><a class="reference internal" href="polyhorn.html">PolyHorn: Polynomial Horn Clause Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="prob.html">Probabilistic Reasoning (arlib/prob)</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers.html">Playing wth Quantifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Model Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="smt.html">SMT Solving</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolic_abstraction.html">Symbolic Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symautomata.html">Symbolic Finite Automata</a></li>
<li class="toctree-l1"><a class="reference internal" href="unsat_core.html">UNSAT Core Extraction</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Arlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Predicate Abstraction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/predicate_abstraction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="predicate-abstraction">
<h1>Predicate Abstraction<a class="headerlink" href="#predicate-abstraction" title="Link to this heading"></a></h1>
<section id="introduction-to-predicate-abstraction">
<h2>Introduction to Predicate Abstraction<a class="headerlink" href="#introduction-to-predicate-abstraction" title="Link to this heading"></a></h2>
<p>Predicate abstraction is a technique for constructing finite-state abstractions
from large or infinite-state systems.</p>
<p>The fundamental operation in predicate abstraction can be summarized as follows:
Given a formula φ and a set of predicates P = {p1, …, pn} in a theory T, generate the most
precise approximation of φ using P.</p>
<p>Depending on the nature of the problem domain, one may either want to generate:</p>
<ol class="lowerroman simple">
<li><p>the best underapproximation of φ, i.e., the weakest Boolean combination
of P that implies φ (denoted by FP(φ)) or</p></li>
<li><p>the best overapproximation of φ, i.e., the strongest Boolean combination of P
that is implied by φ (denoted by GP(φ)).</p></li>
</ol>
<p>Here, the notions of weakness, strength and implication are with respect
to entailment in the given theory T.</p>
</section>
<section id="implementation-in-arlib">
<h2>Implementation in arlib<a class="headerlink" href="#implementation-in-arlib" title="Link to this heading"></a></h2>
<p>arlib implements predicate abstraction in <cite>arlib/symabs/predicate_abstraction/predicate_abstraction.py</cite>.
The implementation focuses on computing the strongest necessary condition of a formula that is
a Boolean combination of the given predicates.</p>
<p>### Core Functions</p>
<ul class="simple">
<li><p><cite>eval_predicates(m, predicates)</cite>: Evaluates a set of predicates in a model <cite>m</cite>, determining
which are true and which are false.</p></li>
<li><p><cite>prime_implicant(ps, e)</cite>: Finds a subset of predicates that together imply a formula,
leveraging unsat cores to minimize the subset.</p></li>
<li><p><cite>check_entailment(antecedent, consequent)</cite>: Checks if one formula entails another using Z3.</p></li>
<li><p><cite>predicate_abstraction(fml, predicates)</cite>: The main function that implements predicate abstraction
following the CAV’06 paper “SMT Techniques for Fast Predicate Abstraction”. This function
computes the strongest Boolean combination of predicates that follows from the input formula.</p></li>
</ul>
<p>### Algorithm Implementation</p>
<p>The main predicate abstraction algorithm works as follows:</p>
<ol class="arabic simple">
<li><p>Initialize a Z3 solver with the input formula</p></li>
<li><p>Maintain a set of results, initially empty</p></li>
<li><p>While the formula is satisfiable:
a. Get a model from the solver
b. Evaluate all predicates in the model
c. Create a conjunction of the evaluated predicates
d. Add this conjunction to the results
e. Add the negation of this conjunction to the solver to exclude it in future iterations</p></li>
<li><p>Return the disjunction of all accumulated conjunctions</p></li>
</ol>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>python
def predicate_abstraction(fml: z3.ExprRef, predicates: List[z3.ExprRef]) -&gt; z3.ExprRef:</p>
<blockquote>
<div><p>“””Compute the strongest necessary condition of fml that is the Boolean combination of preds”””
s = z3.Solver()
s.add(fml)
res = []
while s.check() == z3.sat:</p>
<blockquote>
<div><p>m = s.model()
# Compute a prime/minimal implicant
projs = z3.And(eval_predicates(m, predicates))
res.append(projs)
s.add(negate(projs))</p>
</div></blockquote>
<p>return z3.simplify(z3.Or(res))</p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
</section>
<section id="example-usage">
<h2>Example Usage<a class="headerlink" href="#example-usage" title="Link to this heading"></a></h2>
<p>Consider the following simple C loop:</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>c
int i = 0;
while (i &lt; 10) {</p>
<blockquote>
<div><p>i++;</p>
</div></blockquote>
<section id="id13">
<h3>}<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>Suppose we choose the following predicates as our abstraction:</p>
<p><code class="docutils literal notranslate"><span class="pre">`c</span>
<span class="pre">P1:</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span>
<span class="pre">P2:</span> <span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">10</span>
<span class="pre">`</span></code></p>
<p>To apply predicate abstraction using arlib:</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>python
import z3
from arlib.symabs.predicate_abstraction.predicate_abstraction import predicate_abstraction</p>
<p># Define variables
i = z3.Int(‘i’)</p>
<p># Define the formula (represents the loop body)
formula = z3.And(i &gt;= 0, i &lt; 10, i + 1 &gt;= 0)</p>
<p># Define predicates
P1 = i &lt; 10
P2 = i &gt;= 10
predicates = [P1, P2]</p>
<p># Compute predicate abstraction
result = predicate_abstraction(formula, predicates)
print(z3.simplify(result))  # This will output: i &lt; 10
<a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a></p>
<p>The result expresses that the strongest necessary condition of the formula in terms of the
given predicates is simply <cite>i &lt; 10</cite>, which makes sense as this is the condition for the loop
to continue.</p>
</section>
</section>
<section id="advanced-topics">
<h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Link to this heading"></a></h2>
<p>### Optimization with Prime Implicants</p>
<p>The <cite>prime_implicant</cite> function attempts to find a minimal subset of predicates that imply a
formula. This can be used to optimize the predicate abstraction process by reducing the size
of generated Boolean combinations:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">#</span> <span class="pre">Get</span> <span class="pre">a</span> <span class="pre">more</span> <span class="pre">minimal</span> <span class="pre">representation</span>
<span class="pre">projs</span> <span class="pre">=</span> <span class="pre">z3.And(eval_predicates(m,</span> <span class="pre">predicates))</span>
<span class="pre">projs</span> <span class="pre">=</span> <span class="pre">prime_implicant(projs,</span> <span class="pre">fml)</span>&#160; <span class="pre">#</span> <span class="pre">Further</span> <span class="pre">optimization</span>
<span class="pre">`</span></code></p>
<p>### Scalability Considerations</p>
<p>For large formulas or many predicates, predicate abstraction can become computationally expensive.
Some approaches to improve scalability:</p>
<ol class="arabic simple">
<li><p>Incremental SMT solving to reuse solver state</p></li>
<li><p>Parallel checking of multiple models</p></li>
<li><p>Predicate clustering to handle related predicates together</p></li>
<li><p>Using specialized techniques for specific theories (e.g., linear arithmetic)</p></li>
</ol>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>[GS97] S. Graf and H. Saidi. Construction of abstract state graphs with PVS. In
CAV’97</p></li>
<li><p>[CKSY04] E. Clarke, D. Kroening, N. Sharygina, and K. Yorav. Predicate abstraction
of ANSI–C programs using SAT. FMSD’04</p></li>
<li><p>[LBC03] S. K. Lahiri, R. E. Bryant, and B. Cook. A symbolic approach to predicate
abstraction. In CAV’03</p></li>
<li><p>[LB04] S. K. Lahiri and R. E. Bryant. Constructing Quantified Invariants via
Predicate Abstraction. In VMCAI’04</p></li>
<li><p>[CAV’06] Cimatti, A., Griggio, A., &amp; Sebastiani, R. (2006). SMT Techniques for
Fast Predicate Abstraction. In CAV’06</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024-2025, ZJU Automated Reasoning Group.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>